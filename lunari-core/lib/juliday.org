* 1100 JULDAY

** About the program

*** INPUTs
+ Date or Day (DY) (day number, including times as a fraction of the
  day if appropriate), Month (MN) (month number), Year (YR).

*** OUTPU
Given a date converts it to the number of day since 1900 Junary 0.5
returned by DJ.

*** jeje (?)
+ To conver DJ to JD, simply ad 2415020. This routine works for all
  dates isnce 1st Junary 4713 BC (if the machine has sufficient precision).
+ Astronomers, on the other hand, need to count the years logically,
  taking the year before 1 AD as 0, the year before that as -1
  etc. *Input year BC simply with a negative sign* if you attempt to
  input YR=0 the routine responds with the message "** no year zero
  **", followed by "*** impossble date". The latter message is also
  displayed if you attempt to input any date between 5th and 14th
  October 1582 inclusive. In both cases, the error flalg ER(1) is set
  to 1 to indicate the calling program that and error has
  occurred. Date before 19000 Junary 0.5 return nagative values of DJ.
+ Execution of the subroutine JULDAY is controlled by the flat
  FL(1). When it is called for the first time, or whenever it is
  required to calculate DJ for  new date, FL(1) must be set to 0. In
  line 1110 the flag is set to 1. If, subsequently, the routine is
  called again without the flag having veen reset to 0, DJ is /not/
  recalculated but control is immediately returned to teh calling
  program.

** Formulae

+ $$ DJ = B + C + D + DY - 0.5 days $$
+ If date is before 15th Oct 1582 B = 0
+ If date is equal to, or after 15th October 1582
  B = 2 - A  + INT(A/4)
  A = INT(Y1/100)
+ IF Y1 is negative: C = FNI((365.25 * Y1) -  0.75) - 694025.
+ IF Y1 is zero or positive: C = INT(365.25 * Y1) - 694025.
+ All dates:
  D = INT(30.6001 * (M1 + 1))
+ Y1 = YR < 1 ? YR + 1 : YR
+ If MN = 1 or 2: Y1 = Y1 - 1, M1 = MN + 12
+ IF MN is 3 or more: M1 = MN

#+begin_src python
  from math import ceil, trunc

  def julday(dia, mes, año, hora) -> Optional[int]:
      if año == 0:
          return None

      y1 = año + 1 if y1 < 1 else año
      m1 = mes
      if mes < 3:
          m1 += 12
          y1 -= 1

      oct_15_1582 = ( 15, 10, 1582 )
      # A = ceil(año / 100)
      B = (
          2 - ceil(año / 100 ) + ceil( ceil(año / 100 ) / 4)
          if ( dia, mes, año ) == oct_15_1582 else 0
          )
      C = (
          trunc((365.25*y1)-0.75) - 694025 if y1 < 0 else
          ceil(365.25*y1)
          )
      D = ceil(30.6001 * (m1 + 1))
      return b + c + d + dia - 0.5

#+end_src

** code

#+begin_src ruby
  REM
  REM Subroutine JULDAY
  REM

  IF FL(1) = 1 THEN RETURN # Has this date alredy been converted?
  IF YR == 0 THEN PRINT "** no year zero **" : GOTO 1150 # Check that year is legal
  M1 = MN : Y1=YR : FL(1) = 1 : B = 0 : ER(1) = 0
  IF Y1 < 1 THEN Y1 = Y1 + 1 # No year 0
  IF MN < 3 THEN M1 = MN+12 : Y1=Y1-1
  IF Y1 > 1582 THEN GOTO 1160 # Deal with change to gregorian calendar
  IF Y1 < 1582 THEN GOTO 1165
  IF Y1 = 1582 AND MN < 10 THEN GOTO 1165
  IF Y1 = 1582 AND MN = 10 AND DY < 5 THEN GOTO 1165
  IF MN > 10 OR DY >= 15 THEN GOTO 1160
  ER(1) = 1 : FL(1) = 0 # 1150
  PRINT "*** impossible date" : RETURN

  A = INT(Y1/100) : B = 2-A+INT(A/4) # 1160 # calculate A,B,C,D
  C = INT(365.25 * Y1) - 694025 # 1165
  IF Y1 < 0 THEN C = FNI((365.25 * Y1) - 0.75) - 694025
  D = INT(30.6001 * (M1 + 1)) : DJ = B + C + D + DY - 0.5
  RETURN
#+end_src



** datails of JULDAY

Converts the date DY, MN, YT in DJ (days), the number of julian days
elapsed since 1900 JUNARY 0.5 (= 1899 December 31.5). Count years
'before christ' as negative, with no year 0, thus: BC - 3, -2, -1, 1,
2,3 AD.
If FL(1) = 0 on call, execution of the subroutine proceeds
normally. If FL(1) = 1, on call, then control retuns immediately to
the calling program without calculation of a new DJ. FL(1) is set to 1
oon each new calculation. ER(1) is set to 0 on return from the
subroutine if no error has occured. If date is impossible (see text)
the a message is displayed, ER(1) is set to 1, and the value of DJ is
no altered.

** General Notes
+ In fact, astronomers generally adopt the instant of midday as
  measured at Greenwich on 1st January of the tyear 4713 BC as their
  starting point, or fundamental apoch. Any given calendar date is
  then converted into the number of days elapsed since then and called
  the /Julian day number/, or /Julian date/.
+ Subroutine JULDAY use the basic function ~INT(X)~ to find the
  integer part of the number represented by X. Unfortunately, some
  forms of BASIC use ~INT~ to represent the least-integer function
  while other use it to represent the truncated-integer value. Thus
  ~INT(-32.4)~ would be returned as -33 in the former case and as -32
  in the latter. Both return ~INT~ of positive number identically. IN
  order to overcome this difficulty, JULDAY use tis own integer
  function ~FNI(W)~, which returns the truncated integer part of
  W. this muste be defined in the handling program.
+ ~INT()~ can return either the least-integer or the truncated-integer
  value. ~FNI()~ must return the truncated-integer value.
